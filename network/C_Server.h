/******************************************************************************

  C_Server

  Класс UDP/TCP сервера


  ОПИСАНИЕ

  * Сервер предоставляет возможность принимать входящее соединение по протоколам: UDP, TCP

  * Сервер обеспечивает отправку данных формата data.mes попакетно и согласно времени, указанному внутри
    текущего отправляемого пакета

    Спецификация запросов описана в common_types.h

  * Интерфейс сервера состоит из функции обработчика событий - work()


  ИСПОЛЬЗОВАНИЕ

  1. Для того, чтобы запустить сервер, необходимо создать объект класса
     C_Server, передав в качестве параметров конструктору:

     * лог-метку этого сервера (для идентификации вывода информации от сервера
       в консоль)
     * в виде строки адрес и порт, к которым будет привязан сокет сервера
     * тип протокола: UDP/TCP (см. common_types.h)
     * режим работы используемого сокета: блокирующий/неблокирующий (см. common_types.h)

     C_Server ser( "server", "127.0.0.1:8888",
                   Protocol::TCP, BlockingMode::NonBlocking );

  2. После создания сервера необходимо запустить обработчик событий, вызвав метод
     work():

     ser.work();

******************************************************************************/

#pragma once

#include <QObject>

#include <fstream>
#include <atomic>

#include "C_StreamAnalyzer.h"
#include "C_Logger.h"
#include "utils.h"

namespace network {

using namespace services;

/*****************************************************************************
  Macro Definitions
*****************************************************************************/

/*****************************************************************************
  Forward Declarations
*****************************************************************************/

/*****************************************************************************
  Types and Classes Definitions
*****************************************************************************/

/*****************************************************************************
 * Класс UDP/TCP сервера
 */
class C_Server : public QObject
{

    Q_OBJECT

public:

    C_Server( std::string a_logLabel,
              std::string a_authority,
              std::string a_filePath,
              E_Protocol  a_protoType );

    virtual ~C_Server() = default;

    // Остановить работу сервера
    void stop();


public slots:

    // Главный цикл-обработчик сервера
    void work();

signals:

    // Сигнал для остановки потока сервера
    void finished();

protected:

    /**
     * Обработчики состояний
     */

    // Создание и настройка сокета
    bool setup();
    // Создание сессии с клиентом
    bool connect();
    // Загрузка файла в память
    void loadFile( std::string a_filePath );
    // Отправка пакета клиенту
    bool processPacket( unsigned long &a_idx,
                        std::chrono::milliseconds &a_prevTime,
                        std::chrono::milliseconds &a_sleepTime );
    // Прием данных от клиента
    bool recvPacket();
    // Ожидание между неуспешными итерациями цикла-обработчика, мсек
    void sleep( std::chrono::milliseconds a_sleepTime );

    /**
     * Вспомогательные функции
     */
    // Извлечение команды из пакета данных
    Comand parseComand() const;
    // Преобразование строки в вектор символов
    std::vector<char> convertStrToVec( std::string &&a_str );
    // Отправка данных из файла клиенту
    bool sendPacket( Comand a_comand, std::vector<char> a_payload = {} );
    // Проведение процедуры "handshake" с сервером по UDP протоколу
    void udpConHandler();

protected: // types

    // Перечисление возможных состояний сервера
    enum class E_States {
        Setup,                                  // Настройка всех служб перед работой
        Connect,                                // Подключение
        RecvPacket,                                // Прием сообщения
        ParsePacket,                            // Разбор принятого сообщения
        LoadFile,                               // Загрузить файл с данными с диска
        SendHeader,                             // Отправка заголовка клиенту
        SendPacket,                             // Отправка пакета клиенту
        Finish                                  // Завершение работы
    };

    // Промежуточные состояния установления соединения с клиентом
    enum class E_ConnectionStates {
        WaitReqt,                              // Ожидание эхо-запроса от клиента
        EchoResp,                              // Отправка эхо-ответа клиенту
        VerifyStatus,                          // Проверка статуса соединения с клиентом
        Connected                              // Соединение с клиентом установлено
    };

    // Коды возврата функции setup()
    enum E_SetupRetVal {
        enSockAlreadyCreated = -1,                      // Ошибка, сокет был создан ранее
        enSockCreateError    = -2,                      // Ошибка при создании сокета
        enSockOpenError      = -3,                      // Ошибка при открытии сокета
        enSockSetupError     = -4,                      // Ошибка при конфигурировании сокета
    };

protected slots:

    // Завершение работы сервера
    void close();

protected:

    std::atomic<bool>                   isRunning;          // Атомарный флаг работы главного цикла-обработчика событий сервера
    std::vector<char>                   m_buffer;           // Буфер обмена для приема/отправки сетевых пакетов
    std::string                         m_name;             // Лог-метка сервера
    std::string                         m_authority;        // Адреса и порты клиента и сервера
    E_Protocol                          m_protoType;        // Тип протокола обмена
    std::shared_ptr<I_Socket>           m_handle;           // Сокет сервера
    std::unique_ptr<C_StreamAnalyzer>   m_packetProvider;   // Парсер данных
    std::fstream                        m_file;             // Хендлер файла с данными
    std::vector<char>                   m_data;             // Буфер с данными из файла
    std::string                         m_filePath;         // Путь к файлу с данными

protected: // static

    static const size_t                 s_bufSize;          // Максимальный размер буфера приема-передачи

};

/*****************************************************************************
  Functions Prototypes
*****************************************************************************/

/*****************************************************************************
  Variables Definitions
*****************************************************************************/

/*****************************************************************************
  Inline Functions Definitions
*****************************************************************************/

} // namespace network
